---
phase: 16-service-worker-offline-support
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - public/sw.js
autonomous: true

must_haves:
  truths:
    - "Static JS/CSS assets load from cache on repeat visits"
    - "PWA icons are cached"
    - "API routes always hit network (never cached)"
    - "Old caches are cleaned up when version changes"
  artifacts:
    - path: "public/sw.js"
      provides: "Caching strategies for static assets"
      contains: "caches.open"
  key_links:
    - from: "public/sw.js"
      to: "/_next/static/*"
      via: "cache-first strategy"
      pattern: "_next/static"
    - from: "public/sw.js"
      to: "/icons/*"
      via: "cache-first strategy"
      pattern: "/icons/"
---

<objective>
Add app shell caching to service worker

Purpose: Improve repeat load performance by caching static assets (JS, CSS, icons) while ensuring API data is always fresh.
Output: Service worker with cache-first for statics, network-only for API, versioned cache cleanup.
</objective>

<execution_context>
@/home/pvdochtend/.claude/get-shit-done/workflows/execute-plan.md
@/home/pvdochtend/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-service-worker-offline-support/16-RESEARCH.md
@.planning/phases/16-service-worker-offline-support/16-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add precaching for icons during install</name>
  <files>public/sw.js</files>
  <action>
Update the install event listener in `public/sw.js` to precache icons:

```javascript
const PRECACHE_URLS = [
  '/icons/icon-72x72.png',
  '/icons/icon-96x96.png',
  '/icons/icon-128x128.png',
  '/icons/icon-144x144.png',
  '/icons/icon-152x152.png',
  '/icons/icon-192x192.png',
  '/icons/icon-384x384.png',
  '/icons/icon-512x512.png',
  '/icons/apple-touch-icon.png',
]

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll(PRECACHE_URLS)
    }).then(() => {
      return self.skipWaiting()
    })
  )
})
```

This ensures icons are available offline immediately after SW install.
  </action>
  <verify>grep -q "PRECACHE_URLS" public/sw.js && grep -q "cache.addAll" public/sw.js</verify>
  <done>Icons are precached during service worker install</done>
</task>

<task type="auto">
  <name>Task 2: Add cache cleanup on activate</name>
  <files>public/sw.js</files>
  <action>
Update the activate event listener to clean up old caches:

```javascript
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name.startsWith('habitstreak-') && name !== CACHE_NAME)
          .map((name) => caches.delete(name))
      )
    }).then(() => {
      return self.clients.claim()
    })
  )
})
```

This deletes old habitstreak-* caches when a new version activates, preventing stale assets.
  </action>
  <verify>grep -q "caches.keys" public/sw.js && grep -q "caches.delete" public/sw.js</verify>
  <done>Old caches are deleted on service worker activate</done>
</task>

<task type="auto">
  <name>Task 3: Add cache-first strategy for static assets</name>
  <files>public/sw.js</files>
  <action>
Replace the fetch event listener with full caching logic:

```javascript
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url)

  // Skip non-GET requests
  if (event.request.method !== 'GET') {
    return
  }

  // Network-only for API routes (never cache)
  if (url.pathname.startsWith('/api/')) {
    return
  }

  // Cache-first for static Next.js assets and icons
  if (
    url.pathname.startsWith('/_next/static/') ||
    url.pathname.startsWith('/icons/') ||
    url.pathname === '/manifest.json'
  ) {
    event.respondWith(
      caches.match(event.request).then((cached) => {
        if (cached) {
          return cached
        }
        return fetch(event.request).then((response) => {
          // Don't cache non-ok responses
          if (!response || response.status !== 200) {
            return response
          }
          const clone = response.clone()
          caches.open(CACHE_NAME).then((cache) => {
            cache.put(event.request, clone)
          })
          return response
        })
      })
    )
    return
  }

  // Default: network-first (passthrough, may add offline fallback later)
  event.respondWith(
    fetch(event.request).catch(() => {
      return caches.match(event.request)
    })
  )
})
```

Key behaviors:
- API routes: network-only (no respondWith, browser handles normally)
- Static assets (/_next/static/, /icons/, manifest.json): cache-first with runtime caching
- Everything else: network-first with cache fallback
  </action>
  <verify>grep -q "_next/static" public/sw.js && grep -q "caches.match" public/sw.js</verify>
  <done>Static assets use cache-first strategy, API routes excluded</done>
</task>

</tasks>

<verification>
1. Run `npm run dev` and navigate around the app
2. Open DevTools > Application > Cache Storage
3. Verify habitstreak-v1 cache exists with cached assets
4. Check Network tab: static assets should show "(ServiceWorker)" on repeat visits
5. Verify API calls still hit network (no ServiceWorker source)
6. Change CACHE_VERSION to 'v2', refresh, verify old cache is deleted
</verification>

<success_criteria>
- JS/CSS bundles cached and served from cache on repeat visits
- PWA icons cached and available offline
- API routes bypass cache (network-only)
- Cache cleanup works when version bumps
</success_criteria>

<output>
After completion, create `.planning/phases/16-service-worker-offline-support/16-02-SUMMARY.md`
</output>
