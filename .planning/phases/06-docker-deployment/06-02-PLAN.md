---
phase: 06-docker-deployment
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - Dockerfile
  - docker-compose.prod.yml
  - .env.production.example
autonomous: true

must_haves:
  truths:
    - "Docker image builds successfully under 300MB"
    - "docker-compose.prod.yml starts both app and PostgreSQL"
    - "App container waits for PostgreSQL health check"
    - "Prisma migrations run at container startup"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage production Docker build"
      min_lines: 40
      contains: "FROM node:22-alpine"
    - path: "docker-compose.prod.yml"
      provides: "Production orchestration with PostgreSQL"
      contains: "depends_on"
    - path: ".env.production.example"
      provides: "Production environment template"
      min_lines: 10
  key_links:
    - from: "Dockerfile"
      to: "prisma migrate deploy"
      via: "entrypoint script or CMD"
      pattern: "prisma migrate deploy"
    - from: "docker-compose.prod.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
---

<objective>
Create Docker deployment files for production self-hosting.

Purpose: Enable deployment on Synology NAS and other Docker hosts with PostgreSQL database.
Output: Multi-stage Dockerfile, production docker-compose, environment template.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/phases/06-docker-deployment/06-01-SUMMARY.md

@next.config.js
@docker-compose.yml
@.env.example
@package.json
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfile</name>
  <files>Dockerfile</files>
  <action>
    Create a multi-stage Dockerfile optimized for Next.js standalone output:

    **Stage 1: base**
    - FROM node:22-alpine AS base
    - Set working directory /app

    **Stage 2: deps**
    - FROM base AS deps
    - Install libc6-compat (required for Alpine + Prisma)
    - Copy package.json and package-lock.json
    - Run npm ci --only=production (no devDependencies)
    - Copy prisma directory
    - Run npx prisma generate

    **Stage 3: builder**
    - FROM base AS builder
    - Copy node_modules from deps stage
    - Copy all source files
    - Set DATABASE_URL dummy for build (Prisma needs it to parse schema)
    - Run npm run build

    **Stage 4: runner**
    - FROM base AS runner
    - Set NODE_ENV=production
    - Create non-root user (nextjs:nodejs)
    - Copy from builder:
      - public directory
      - .next/standalone
      - .next/static
      - prisma directory (for migrations)
    - Set HOSTNAME="0.0.0.0" PORT=3000
    - Expose port 3000
    - CMD: Run prisma migrate deploy, then node server.js

    **Critical details:**
    - Use node:22-alpine (not node:22 - saves ~800MB)
    - DATABASE_URL at build time: Use dummy postgres://localhost/temp
    - Don't COPY .env files (secrets must come from environment)
    - CMD should run migrations then server (or use entrypoint script)

    **For migrations at startup, use:**
    ```dockerfile
    CMD ["sh", "-c", "npx prisma migrate deploy && node server.js"]
    ```
  </action>
  <verify>docker build -t habitstreak:test . completes successfully</verify>
  <done>Dockerfile builds successfully with all 4 stages</done>
</task>

<task type="auto">
  <name>Task 2: Create docker-compose.prod.yml</name>
  <files>docker-compose.prod.yml</files>
  <action>
    Create production docker-compose that orchestrates app + PostgreSQL:

    ```yaml
    services:
      app:
        build:
          context: .
          dockerfile: Dockerfile
        container_name: habitstreak-app
        restart: unless-stopped
        ports:
          - '3000:3000'
        environment:
          - DATABASE_URL=postgresql://habitstreak:${POSTGRES_PASSWORD}@postgres:5432/habitstreak
          - NEXTAUTH_URL=${NEXTAUTH_URL}
          - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
          - TZ=Europe/Amsterdam
        depends_on:
          postgres:
            condition: service_healthy
        healthcheck:
          test: ['CMD', 'wget', '-q', '--spider', 'http://localhost:3000/api/health']
          interval: 30s
          timeout: 10s
          retries: 3
          start_period: 40s

      postgres:
        image: postgres:16-alpine
        container_name: habitstreak-db
        restart: unless-stopped
        environment:
          POSTGRES_USER: habitstreak
          POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
          POSTGRES_DB: habitstreak
        volumes:
          - postgres_data:/var/lib/postgresql/data
        healthcheck:
          test: ['CMD-SHELL', 'pg_isready -U habitstreak']
          interval: 10s
          timeout: 5s
          retries: 5

    volumes:
      postgres_data:
    ```

    **Critical details:**
    - App depends_on postgres with condition: service_healthy
    - DATABASE_URL uses service name 'postgres' (not localhost)
    - Health check uses wget (curl not in alpine by default)
    - start_period gives time for migrations to run
    - POSTGRES_PASSWORD comes from environment (not hardcoded)
    - Port 3000 exposed (Synology can map to any host port)
  </action>
  <verify>docker-compose -f docker-compose.prod.yml config validates successfully</verify>
  <done>docker-compose.prod.yml orchestrates app and PostgreSQL with health checks</done>
</task>

<task type="auto">
  <name>Task 3: Create .env.production.example</name>
  <files>.env.production.example</files>
  <action>
    Create production environment template with documentation:

    ```env
    # HabitStreak Production Environment
    # Copy this file to .env.production and fill in your values
    # NEVER commit .env.production to git!

    # ============================================
    # REQUIRED: Database
    # ============================================
    # PostgreSQL password for the 'habitstreak' user
    # Generate a strong password: openssl rand -base64 32
    POSTGRES_PASSWORD=change_me_to_a_strong_password

    # ============================================
    # REQUIRED: NextAuth
    # ============================================
    # The URL where your app is accessible
    # Example: https://habits.yourdomain.com or http://192.168.1.100:3000
    NEXTAUTH_URL=http://localhost:3000

    # Secret for JWT signing - MUST be at least 32 characters
    # Generate with: openssl rand -base64 32
    NEXTAUTH_SECRET=change_me_to_a_random_string_at_least_32_chars

    # ============================================
    # OPTIONAL: Timezone
    # ============================================
    # Default: Europe/Amsterdam (hardcoded in app)
    # TZ=Europe/Amsterdam
    ```

    **Documentation notes:**
    - Include generation commands for secrets
    - Explain each variable's purpose
    - Mark required vs optional
    - Warn about not committing to git
  </action>
  <verify>File exists with all required variables documented</verify>
  <done>.env.production.example documents all required environment variables</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `docker build -t habitstreak:test .` completes successfully
- [ ] `docker images habitstreak:test --format "{{.Size}}"` shows under 300MB
- [ ] `docker-compose -f docker-compose.prod.yml config` validates
- [ ] `.env.production.example` contains all required variables with documentation
</verification>

<success_criteria>
- All tasks completed
- Docker image builds under 300MB
- Compose file validates
- Environment template complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-docker-deployment/06-02-SUMMARY.md`
</output>
